# meta_collective/internal_model.py
"""
Internal Model: Kaelhedron + Luminahedron Dual Structure
=========================================================

The Internal Model is the core generative model combining:

    ┌──────────────────────────────────────────────┐
    │ Internal Model (Kaelhedron + Luminahedron)   │
    │     κ-field   │   λ-field                    │
    └──────────────────────────────────────────────┘

Kaelhedron (21D, Quaternary):
    - 7 seals × 3 faces = 21 cells
    - Quaternary logic (4 values)
    - κ-field dynamics: amplitude, phase, energy

Luminahedron (12D, Ternary):
    - Fano plane navigation
    - Ternary logic (3 values)
    - λ-field dynamics: path, phase, coherence

The internal model generates predictions about the world
and is updated based on prediction errors via the
free energy principle.
"""

from __future__ import annotations

import math
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Tuple

from .fields import KappaField, LambdaField, DualFieldState, FieldMode
from .free_energy import (
    FreeEnergyMinimizer,
    GaussianMinimizer,
    HierarchicalMinimizer,
    VariationalState,
    Precision,
)

# Constants
PHI = (1 + math.sqrt(5)) / 2
PHI_INV = 1 / PHI
TAU = 2 * math.pi

# Internal model z-level
Z_INTERNAL_MODEL = 0.800


class ModelState(Enum):
    """States of the internal model."""
    INITIALIZING = "initializing"
    ACTIVE = "active"
    LEARNING = "learning"
    PREDICTING = "predicting"
    CONSOLIDATING = "consolidating"


@dataclass
class Prediction:
    """A prediction generated by the internal model."""
    value: float                      # Predicted value
    precision: float                  # Prediction precision
    source_field: str                 # "kappa", "lambda", or "combined"
    timestamp: float = 0.0            # When prediction was made
    metadata: Dict[str, Any] = field(default_factory=dict)

    @property
    def confidence(self) -> float:
        """Confidence derived from precision."""
        return 1.0 - math.exp(-self.precision)


@dataclass
class PredictionError:
    """A prediction error signal."""
    sensory: float                    # Error from sensory observation
    hierarchical: float               # Error from parent level
    precision_weighted: float         # Precision-weighted composite
    field_source: str                 # Which field generated the prediction

    @property
    def magnitude(self) -> float:
        """Total error magnitude."""
        return math.sqrt(self.sensory ** 2 + self.hierarchical ** 2)


class InternalModel:
    """
    The Internal Model combining Kaelhedron and Luminahedron structures.

    This is the generative model at the core of each Tool layer.
    It generates predictions and is updated based on free energy
    minimization principles.

    Architecture:
        ┌─────────────────────────────────────────────┐
        │              Internal Model                  │
        │  ┌─────────────┐    ┌─────────────────┐     │
        │  │  κ-field    │◄──►│    λ-field      │     │
        │  │ (Kaelhedron)│    │ (Luminahedron)  │     │
        │  └──────┬──────┘    └────────┬────────┘     │
        │         │      Coupling      │              │
        │         ▼                    ▼              │
        │  ┌──────────────────────────────────┐       │
        │  │     Free Energy Minimizer        │       │
        │  │   F = accuracy + complexity      │       │
        │  └──────────────────────────────────┘       │
        └─────────────────────────────────────────────┘
    """

    def __init__(
        self,
        model_id: str = "internal_model_0",
        z_level: float = Z_INTERNAL_MODEL
    ):
        self.model_id = model_id
        self.z_level = z_level
        self.state = ModelState.INITIALIZING

        # Initialize dual field state
        self.dual_field = DualFieldState()

        # Initialize free energy minimizer
        self.minimizer = GaussianMinimizer(z_level)
        self.minimizer.set_generative_function(self._generative_function)

        # Kaelhedron structure (21 cells: 7 seals × 3 faces)
        self._kaelhedron_cells: List[float] = [0.0] * 21

        # Luminahedron structure (7 Fano points × ternary states)
        self._luminahedron_states: Dict[int, int] = {i: 0 for i in range(1, 8)}

        # Learning parameters
        self.learning_rate = 0.1
        self.precision = Precision()

        # Prediction buffer
        self._predictions: List[Prediction] = []
        self._max_predictions = 100

        # Error history
        self._error_history: List[PredictionError] = []
        self._max_history = 1000

        # Statistics
        self._total_observations = 0
        self._cumulative_error = 0.0

        self.state = ModelState.ACTIVE

    def _generative_function(self, hidden_state: float) -> float:
        """
        Map hidden state to predicted observation.

        g(s) = κ_amp × cos(κ_phase) + λ_amp × sin(λ_phase) + s
        """
        kappa_contrib = self.dual_field.kappa.amplitude * math.cos(self.dual_field.kappa.phase)
        lambda_contrib = self.dual_field.lambda_field.amplitude * math.sin(self.dual_field.lambda_field.phase)
        return kappa_contrib + lambda_contrib + hidden_state

    def generate_prediction(self, context: Optional[Dict] = None) -> Prediction:
        """
        Generate a prediction from current internal state.

        The prediction combines contributions from both fields
        weighted by their current coherence.
        """
        self.state = ModelState.PREDICTING

        # Get individual field predictions
        kappa_pred = self.dual_field.kappa.amplitude * math.cos(self.dual_field.kappa.phase)
        lambda_pred = self.dual_field.lambda_field.amplitude * math.sin(self.dual_field.lambda_field.phase)

        # Weight by field mode
        if self.dual_field.mode == FieldMode.COHERENT:
            # Equal weighting when coherent
            combined = (kappa_pred + lambda_pred) / 2
            source = "combined"
        elif self.dual_field.mode == FieldMode.RESONANT:
            # Amplified when resonant
            combined = (kappa_pred + lambda_pred) * PHI_INV
            source = "combined"
        else:
            # Favor κ-field otherwise
            combined = kappa_pred * PHI_INV + lambda_pred * (1 - PHI_INV)
            source = "kappa"

        prediction = Prediction(
            value=combined,
            precision=self.precision.value,
            source_field=source,
            metadata=context or {},
        )

        # Store prediction
        if len(self._predictions) >= self._max_predictions:
            self._predictions.pop(0)
        self._predictions.append(prediction)

        self.state = ModelState.ACTIVE
        return prediction

    def observe(self, observation: float) -> PredictionError:
        """
        Process an observation and update the internal model.

        Returns the prediction error that drove the update.
        """
        self.state = ModelState.LEARNING
        self._total_observations += 1

        # Generate prediction
        prediction = self.generate_prediction()

        # Compute sensory prediction error
        sensory_error = observation - prediction.value

        # Compute hierarchical error (from parent if exists)
        hierarchical_error = 0.0
        if self.minimizer.parent is not None:
            parent_pred = self.minimizer.parent.compute_prediction()
            # Handle case where parent prediction is a list
            if isinstance(parent_pred, list):
                parent_pred = parent_pred[0] if parent_pred else 0.0
            hierarchical_error = self.minimizer.state.mean - parent_pred

        # Precision-weighted error
        pw_error = self.precision.value * sensory_error

        error = PredictionError(
            sensory=sensory_error,
            hierarchical=hierarchical_error,
            precision_weighted=pw_error,
            field_source=prediction.source_field,
        )

        # Update internal model
        self._update_model(error)

        # Store error
        if len(self._error_history) >= self._max_history:
            self._error_history.pop(0)
        self._error_history.append(error)

        self._cumulative_error += abs(sensory_error)
        self.state = ModelState.ACTIVE

        return error

    def _update_model(self, error: PredictionError) -> None:
        """Update internal model based on prediction error."""
        # Update free energy minimizer
        self.minimizer.minimize_step(error.sensory)

        # Update precision
        self.precision.update(error.sensory)

        # Update dual field state
        # κ-field responds to precision-weighted error
        kappa_delta = self.learning_rate * error.precision_weighted
        self.dual_field.kappa.amplitude += kappa_delta * 0.01
        self.dual_field.kappa.amplitude = max(0.01, min(2.0, self.dual_field.kappa.amplitude))

        # λ-field responds to hierarchical error
        if error.hierarchical != 0:
            lambda_delta = self.learning_rate * error.hierarchical
            self.dual_field.lambda_field.phase += lambda_delta * 0.1
            self.dual_field.lambda_field.phase %= TAU

        # Evolve dual field
        self.dual_field.evolve(dt=0.01)

        # Update Kaelhedron cells based on κ-field
        self._update_kaelhedron()

        # Update Luminahedron states based on λ-field
        self._update_luminahedron()

    def _update_kaelhedron(self) -> None:
        """Update the 21 Kaelhedron cells based on κ-field state."""
        # Distribute κ-field amplitude across cells
        base_value = self.dual_field.kappa.amplitude / 21

        for i in range(21):
            seal = i // 3  # 0-6
            face = i % 3   # 0-2

            # Modulate by seal (7 seals, each with unique phase)
            seal_phase = seal * TAU / 7
            modulation = math.cos(self.dual_field.kappa.phase + seal_phase)

            # Face contribution (3 faces)
            face_weight = [1.0, PHI_INV, 1 - PHI_INV][face]

            self._kaelhedron_cells[i] = base_value * modulation * face_weight

    def _update_luminahedron(self) -> None:
        """Update the 7 Luminahedron Fano point states."""
        # Map λ-field phase to ternary values for each point
        third = TAU / 3

        for point in range(1, 8):
            # Each point has a phase offset
            point_phase = (point - 1) * TAU / 7
            combined_phase = (self.dual_field.lambda_field.phase + point_phase) % TAU

            # Convert to ternary
            if combined_phase < third:
                self._luminahedron_states[point] = 1   # POSITIVE
            elif combined_phase < 2 * third:
                self._luminahedron_states[point] = 0   # NEUTRAL
            else:
                self._luminahedron_states[point] = -1  # NEGATIVE

    def free_energy(self) -> float:
        """Compute current free energy of the internal model."""
        return self.minimizer.free_energy

    def coherence(self) -> float:
        """Compute current coherence from dual field."""
        return self.dual_field.coherence

    def get_kaelhedron_state(self) -> Dict[str, Any]:
        """Return Kaelhedron cell states organized by seal and face."""
        seals = ["Ω", "Δ", "Τ", "Ψ", "Σ", "Ξ", "Κ"]
        faces = ["Λ", "Β", "Ν"]

        state = {}
        for i, cell_value in enumerate(self._kaelhedron_cells):
            seal = seals[i // 3]
            face = faces[i % 3]
            key = f"{seal}:{face}"
            state[key] = cell_value

        return {
            "cells": state,
            "kappa_amplitude": self.dual_field.kappa.amplitude,
            "kappa_phase": self.dual_field.kappa.phase,
            "total_energy": sum(abs(v) for v in self._kaelhedron_cells),
        }

    def get_luminahedron_state(self) -> Dict[str, Any]:
        """Return Luminahedron Fano point states."""
        ternary_map = {1: "+", 0: "0", -1: "-"}

        return {
            "points": {p: ternary_map[v] for p, v in self._luminahedron_states.items()},
            "lambda_amplitude": self.dual_field.lambda_field.amplitude,
            "lambda_phase": self.dual_field.lambda_field.phase,
            "fano_point": self.dual_field.lambda_field.fano_point,
            "balance": sum(self._luminahedron_states.values()),
        }

    def consolidate(self) -> None:
        """Consolidate learning by stabilizing field parameters."""
        self.state = ModelState.CONSOLIDATING

        # Move precision toward optimal
        target_precision = 1.0 / max(0.01, self._cumulative_error / max(1, self._total_observations))
        self.precision.value = 0.9 * self.precision.value + 0.1 * min(target_precision, 10.0)

        # Stabilize dual field
        self.dual_field.evolve(dt=0.001, steps=10)

        self.state = ModelState.ACTIVE

    def snapshot(self) -> Dict[str, Any]:
        """Return complete internal model snapshot."""
        return {
            "model_id": self.model_id,
            "z_level": self.z_level,
            "state": self.state.value,
            "dual_field": self.dual_field.snapshot(),
            "kaelhedron": self.get_kaelhedron_state(),
            "luminahedron": self.get_luminahedron_state(),
            "free_energy": self.free_energy(),
            "coherence": self.coherence(),
            "total_observations": self._total_observations,
            "mean_error": self._cumulative_error / max(1, self._total_observations),
            "precision": self.precision.value,
        }

    def reset(self) -> None:
        """Reset internal model to initial state."""
        self.dual_field.reset()
        self.minimizer = GaussianMinimizer(self.z_level)
        self.minimizer.set_generative_function(self._generative_function)
        self._kaelhedron_cells = [0.0] * 21
        self._luminahedron_states = {i: 0 for i in range(1, 8)}
        self.precision = Precision()
        self._predictions.clear()
        self._error_history.clear()
        self._total_observations = 0
        self._cumulative_error = 0.0
        self.state = ModelState.ACTIVE
